# 螺旋矩阵

## 1. 知识点

> 1. 学会如何使用反向range -1的形式
>
>    ```python
>    for i in range(r, l - 1, -1):
>    ...
>    for i in range(b, t - 1, -1):
>    
>    range(r, l - 1, -1) 生成的序列是 r, r-1, ..., l（包含 l）。
>    
>    range(b, t - 1, -1) 生成的序列是 b, b-1, ..., t（包含 t）。
>    
>    常见陷阱
>    
>    方向要与步长一致：用负步长时必须 start > stop，否则结果为空：list(range(1, 5, -1)) -> []。
>    
>    结束值不包含，想“包含某端点”要相应地 ±1
>    ```
>
> 2. **思想就是：定义边界，每次运行完向里面缩，知道条件终止break**

## 2. 代码：

```python
DIRS = (0, 1), (1, 0), (0, -1), (-1, 0)  # 右下左上

class Solution:
    def spiralOrder(self, matrix: List[List[int]]) -> List[int]:
        if not matrix: return []
        # 0, 2, 0, 2
        l, r, t, b, res = 0, len(matrix[0]) - 1, 0, len(matrix) - 1, []
        # 运行完一圈回来, 1, 1, 1, 1
        while True:
            for i in range(l, r+1):
                # 左闭右开区间
                res.append(matrix[t][i])
            t += 1
            # 0, 2, 1, 2
            if t > b:break
            for i in range(t, b+1):
                res.append(matrix[i][r])
            r -= 1
            # 0, 1, 1, 2
            if l > r: break
            for i in range (r, l-1, -1): 
                res.append(matrix[b][i])
            b -= 1
            # 0, 1, 1, 1
            if t > b: break
            for i in range(b, t-1, -1):
                res.append(matrix[i][l])
            l += 1
            # 1, 1, 1, 1
            if l > r: break
        return res

```

