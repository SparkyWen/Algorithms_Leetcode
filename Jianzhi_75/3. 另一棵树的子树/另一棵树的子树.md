# 另一棵树的子树

## 1. 知识点

> 1. 树的高度
>
>    ```py
>            1
>           / \
>          2   3
>         /
>        4
>         \
>          5
>    
>    ```
>
>    整体的执行过程如下:
>
>    现在调用 `getHeight(root=1)`，按递归执行顺序（后序：先左再右再根）：
>
>    1. `getHeight(1)` → root 不是 None，去计算左子树 `getHeight(2)` 和右子树 `getHeight(3)`。
>    2. 进入 `getHeight(2)`：
>       - 计算 `getHeight(4)`（2 的左）。
>       - `getHeight(4)`：
>         - 计算 `getHeight(None)` → 返回 0（4.left 是 None）
>         - 计算 `getHeight(5)`（4.right）
>           - `getHeight(5)`：
>             - 左 `None` → 0
>             - 右 `None` → 0
>             - 返回 `max(0,0)+1 = 1` → 所以节点 5 的高度是 1
>         - 回到节点 4： left_h = 0, right_h = 1 → 返回 `max(0,1)+1 = 2` → 节点 4 高度 2
>       - 回到节点 2： left_h = 2, right_h = 0（2.right 是 None）→ 返回 `max(2,0)+1 = 3` → 节点 2 高度 3
>    3. `getHeight(3)`：3 的左右都是 None → 左 0、右 0 → 返回 `1` → 节点 3 高度 1
>    4. 回到根节点 1： left_h = 3, right_h = 1 → 返回 `max(3,1)+1 = 4`
>
>    所以整棵树高度 = **4**（按节点计数：从根 1 到最深叶 5，路径长度 4 个节点：1→2→4→5）。

> 2. 补充摩根定律，一般是只有not 的时候才会这样写，如果是is ...而不是否定逻辑的是否不会这样写
>
> ```python
> 原式是：
> if (p is None) or (q is None):
>     return p is q
> 
> 把它记为：A or B，其中
> A ≡ (p is None)，B ≡ (q is None)。
> 按摩根定律：
> A or B  ≡  not( (not A) and (not B) )
>         ≡  not( (p is not None) and (q is not None) )
> 
> 所以等价写法是：
> if not ( (p is not None) and (q is not None) ):
>     return p is q
> 
> 而你写的
> if not p and q:
>     ...
> 
> 或
> if not (p and q):
>     ...
> 
> 把 A、B 误换成了 p 和 q 自身的真值（0、''、[] 也会被当作 False），不再是“是否为 None”的判断，语义完全变了。
> 结论：
> 
> 
> ✅ 正确的“摩根化”写法：if not (p is not None and q is not None): ...
> 
> ❌ if not p and q / if not (p and q) 都不等价（它们用的是 truthy/falsy，而不是 is None）。
> 
> ```

> 3. 相同的树
>
> 这里涉及了一个重要的**知识点return**的截断
>
> ```python
> def isSameTree(p, q):
>     if p is None or q is None:
>         return p is q                     # 进入这里就结束，不会再往下执行
>     return (p.val == q.val                # 先算这个；若为 False，后面两项不算
>             and isSameTree(p.left, q.left)    # 只有前一个为真才会算
>             and isSameTree(p.right, q.right)) # 只有前两项都真才会算
> 若走到第二个 return，求值过程是：
> 计算 p.val == q.val
> 若为 False → 短路，不再递归左右子树，直接返回 False
> 若为 True → 计算 isSameTree(p.left, q.left)；如果这步为 False，再次短路，不算右子树
> 只有前三项都为 True，才会继续算最后一项并最终返回 True
> 这能大幅减少不必要的递归调用。
> ```
>
> 继续举例：
>
> ### 执行过程（关键处解释）
>
> 1. 进入 `dfs(root)`
>
> 2. 进入左递归：`dfs(root.left)`，此时 `root.left is None`，触发
>
>    ```
>    return 0, False
>    ```
>
>    ——**这里仅结束这一次“左子树”的 dfs 调用**，返回 `(0, False)` 给谁？给**调用它的那一层**（也就是 `dfs(root)`）。
>
> 3. 回到上一层（也就是“外层/调用者” `dfs(root)`），它把返回值**解包赋值**：
>
>    ```
>    left_h, left_found = (0, False)  # 取到结果
>    ```
>
>    然后外层会继续执行**它后面的代码**（这就是“还能继续往下走”）：
>
>    ```
>    print(f"[back to root] after left, got left_h=0, left_found=False")
>    right_h, right_found = dfs(root.right)  # 继续去算右子树
>    ...
>    ```
>
>    注意：**外层是否继续**，取决于外层自己的逻辑。比如外层若写了
>
>    ```
>    if left_found or right_found:
>        return 0, True
>    ```
>
>    那么当 `left_found` 为 True 时，外层也会 `return`，从而**结束外层**；但这是**外层自己选择 return**，不是内层的 return 直接“杀死”外层。
>
>    **为什么还需要这个 dfs（返回二元组）**
>
> ```python
> 作用一：一次 DFS 同时获取高度与“是否找到”
> 
> 遍历时，自底向上返回高度，让父节点能 O(1) 计算自己的高度。
> 
> 同时携带“是否找到”这个布尔值，一旦某个子树已经找到，上层能立刻早停（if left_found or right_found: return 0, True），避免继续做无谓的比较。
> 
> 作用二：剪枝减少 isSameTree 调用次数
> 
> 只有当 node_h == hs 时才比较整棵树是否相同——大量节点会被过滤掉（高度不等不可能是同一棵子树）。
> 
> 作用三：避免重复计算高度
> 
> 如果你先单独用 getHeight 计算每个节点的高度，那会产生重复遍历。现在用一次 DFS 就把所有节点高度自底向上统统算出来了。
> 
> ```

## 2. 代码和计算过程

```python
class Solution:
    def getHeight(self, root):
        if root is None:
            return 0
        left_h = self.getHeight(root.left)
        right_h = self.getHeight(root.right)
        return max(left_h, right_h) + 1
    def isSameTree(self, root):
        if p is None or q is None:
            return p is q
        return p.val == q.val and \
            self.isSameTree(p.left, q.left) and \
            self.isSameTree(p.right, q.right)
         
    def isSubtree(self, root: Optional[TreeNode], subRoot: Optional[TreeNode]) -> bool:
        hs = self.getHeight(subRoot)

        def dfs(node):
            if node is None:
                return 0, False
            left_h, left_found = dfs(node.left)
            right_h, right_found = dfs(node.right)
            if left_found or right_found:
                return 0, True
            node_h = max(left_h, right_h) + 1
            return node_h, node_h == hs and self.isSameTree(node, subRoot)
        return dfs(root)[1]
```

```python
root:                     subRoot:
      1                       2
     / \                     /
    2   3                   4
   /
  4
getHeight(subRoot)：

4 的高度 = 1

2 的高度 = max(1,0)+1 = 2 → 所以 hs = 2

从 root 开始做 dfs：

到达叶子 4：

左右 None → 各返回 (0, False)

node_h = max(0,0)+1 = 1

比较条件 node_h == hs？1 == 2 → 否，found_here=False

返回 (1, False)

回到 2（左子树根）：

左收到 (1, False)，右是 None 收到 (0, False)

左右都未“found”，继续

node_h = max(1,0)+1 = 2

node_h == hs → 2 == 2 ✔，触发 isSameTree(node=2, subRoot)

逐节点比对：2 值相同；左子树都是 4；右子树都是 None → True

返回 (2, True)

回到 1：

左收到 (..., True)，于是 if left_found or right_found: 成立，直接 return (0, True)，不再继续计算右边或做额外比较。

顶层 dfs(root) 最终 [1] 为 True，于是 isSubtree 返回 True。

这个例子你能看到两点：

只有高度相等的节点才触发了 isSameTree，减少了开销；

一旦子树找到，上层快速早停，不再做无谓的递归。
```

