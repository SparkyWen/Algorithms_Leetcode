# 二叉树的最大深度

## 1. 知识点

1.关键点在于理解深度和左右子树的关系：

**关键点：** 此树的深度和其左（右）子树的深度之间的关系。显然，**此树的深度** 等于 **左子树的深度** 与 **右子树的深度**中的 **最大值** +1 。

2.算法解析：
	终止条件： 当 root 为空，说明已越过叶节点，因此返回 深度 0 。
	递推工作： 本质上是对树做后序遍历。
	计算节点 root 的 左子树的深度 ，即调用 `maxDepth(root.left)`。
	计算节点 root 的 右子树的深度 ，即调用 `maxDepth(root.right)`。
	返回值： 返回 此树的深度 ，即 `max(maxDepth(root.left), maxDepth(root.right)) + 1`。

3.补充一个奇怪的报错：

```python
queue, res = collections.deque(), 0
queue.append(root)
while queue:
    for node in queue:              # ⛔ 在遍历 queue 的同时
        if node.left: queue.append(node.left)   # ⛔ 又往 queue 里 append
        if node.right: queue.append(node.right)
    res += 1
return res
```

**意思是：正在 for node in queue 遍历 deque 的时候，你又修改了这个 deque（append），Python 不允许这样。**

对 list 来说，for x in list_obj 时修改 list 虽然「不推荐」，但不会直接抛错，只是逻辑很难控制；

对 deque，Python 直接帮你「拦下来」，抛出 RuntimeError: deque mutated during iteration，避免一堆奇怪行为。

所以你这段代码的问题不是「不能用 deque」，而是 遍历对象和被修改对象是同一个队列。

关键就差在一句话：

> ❌ 之前是：**“遍历 queue 的 iterator 的同时改 queue”**
>  ✅ 现在是：**“只循环固定次数 level_size，顺便改 queue”**

看起来都是“在循环里改同一个队列”，但**循环对象不一样**，导致行为完全不同。

## 2. 代码

```python
class Solution:
    def maxDepth(self, root: Optional[TreeNode]) -> int:
        if not root: return 0
        return max(self.maxDepth(root.left), self.maxDepth(root.right)) + 1
```

==解释==：

## 1. 先回顾两种写法

### 之前报错的写法（简化版）

```
queue = collections.deque([root])
while queue:
    for node in queue:              # ← 直接遍历 queue 本身
        if node.left:
            queue.append(node.left) # ← 往同一个 queue 里 append
        if node.right:
            queue.append(node.right)
```

报错：

> ```
> RuntimeError: deque mutated during iteration
> ```

### 现在正确的写法

```
queue = collections.deque([root])
depth = 0
while queue:
    level_size = len(queue)         # 这一层一共有多少个节点
    for _ in range(level_size):     # ← 只循环这么多次
        node = queue.popleft()      # ← 每次从队头拿一个
        if node.left:
            queue.append(node.left)
        if node.right:
            queue.append(node.right)
    depth += 1
```

你问：**“现在不也是在修改同一个 queue 吗？为什么这次就没问题？”**

答案是：是的，同一个 queue，但是——

- 之前：`for node in queue` 是**基于 deque 的迭代器**来走的；
- ==现在：`for _ in range(level_size)` 是**基于一个固定长度的 range 对象**来走的，和 `queue` 本身解耦==。

## 2. 之前的做法到底哪里出问题？

```
for node in queue:
    ...
    queue.append(...)
```

这段代码本质上是：

1. `for node in queue` 会先创建一个 **deque 的迭代器**，它内部记录了当前遍历位置，也假设“你遍历的时候不要再改我这个 deque 的结构”；

2. 你在循环体里又 `queue.append()`，相当于**一边用这个迭代器遍历，一边修改它背后的容器**；

3. 对 list 来说，虽然逻辑会变得很难理解，但 Python 允许这样（只是结果可能不符合预期）；
    对 `deque`，官方直接拦截这种用法，抛出：

   > `RuntimeError: deque mutated during iteration`

这是设计层面上刻意保护你：避免因为边遍历边改而出现非常怪的行为（比如漏元素、重复元素、死循环）。

## 3. 那现在的写法为什么就安全？

来看你现在的代码：

```
while queue:
    level_size = len(queue)         # 当前层节点个数（一个 int）
    for _ in range(level_size):     # ← 这里遍历的是“range 对象”，和 queue 没关系
        node = queue.popleft()      # 每次从队头弹出一个
        if node.left:
            queue.append(node.left) # 向队尾加新节点
        if node.right:
            queue.append(node.right)
```

这里有两个关键点：

### ✅ 关键点 1：for 循环遍历的不是 `queue`，而是 `range(level_size)`

- ## `for _ in range(level_size)` 使用的是 `range` 提供的迭代器；

- `range(level_size)` 一开始就固定好了长度 = `level_size`；

- 即使你在循环体里修改了 `queue` 的长度，**也不会影响 `range` 的长度**，它还是老老实实循环 `level_size` 次。

所以**循环控制权完全由 `range` 决定**，而不是 `queue`。

### ✅ 关键点 2：我们自己保证逻辑正确 —— “这一层只处理原来的 level_size 个节点”

- `level_size = len(queue)` 的那一刻，`queue` 中放的，恰好是“当前这一层”的所有节点；
- `for _ in range(level_size)` 就是“我只处理这一层的这些节点”：
  - 每次 `popleft()` 拿掉队头的一个“当前层节点”；
  - `append()` 的是“下一层节点”，排在队尾，**不会在本轮 for 被处理到**；
- 当 for 循环跑完 `level_size` 次：
  - 当前层所有节点已经出队；
  - 下一层节点刚好**全部在队列里**；
  - 下一次 `while queue:` 再处理下一层。

所以虽然我们在循环里不停地 `popleft()` 和 `append()`，队列被修改了很多次，但：

- **for 循环的“步数”是固定的（range(level_size)）**；
- **每一次处理的 node 都是当前层原先就有的节点**；
- 本层新加进去的子节点只在下一轮 while 中被处理。

Python 当然不反对你：

> “遍历一个固定次数的循环，并且循环体里改某个容器”。

它只反对你：

> “遍历一个**依赖容器本身状态**的迭代器（比如 `for x in queue`），同时又修改这个容器”。

