# 翻转二叉树

## 1. 知识点

> 1. 常规思想
>
>    我们在做二叉树题目时候，第一想到的应该是用 **递归 来**解决。
>    仔细看下题目的 输入 和 输出，输出的左右子树的位置跟输入正好是相反的，于是我们可以递归的交换左右子树来完成这道题。

> 2. 迭代思想
>
>    **递归实现也就是深度优先遍历的方式，那么对应的就是广度优先遍历。**
>    **广度优先遍历需要额外的数据结构--队列，来存放临时遍历到的元素。**
>    深度优先遍历的特点是一竿子插到底，不行了再退回来继续；而广度优先遍历的特点是层层扫荡。
>    所以，我们需要先将根节点放入到队列中，然后不断的迭代队列中的元素。
>    对当前元素调换其左右子树的位置，然后：
>
>    判断其左子树是否为空，不为空就放入队列中
>    判断其右子树是否为空，不为空就放入队列中



## 2. 代码

1. 递归思想

   ```python
   class Solution(object):
       def invertTree(self, root):
           """
           :type root: TreeNode
           :rtype: TreeNode
           """
           # 1) 递归结束条件：空节点直接返回
           if not root:
               return None
   
           # 2) 交换当前节点的左右子树
           root.left, root.right = root.right, root.left
   
           # 3) 递归翻转（已经交换过位置的）左、右子树
           self.invertTree(root.left)
           self.invertTree(root.right)
   
           # 4) 返回当前节点（此节点为根的整棵子树已翻转完成）
           return root
   ```

   ```python
   2.1 初始树（翻转前）
   
   我们用一棵完全二叉树举例（数字是节点值）：
   
            4
          /   \
         2     7
        / \   / \
       1   3 6   9
   
   
   目标：把每个节点的 left 与 right 交换，翻转后应该变成：
   
            4
          /   \
         7     2
        / \   / \
       9   6 3   1
   
   2.2 递归的调用顺序（先序：根 → 左 → 右）
   
   我用“调用栈帧”的方式展示（invertTree(节点值) 表示以该节点为根的调用）：
   
   调用 invertTree(4)
   
   交换 4.left 和 4.right（2 ↔ 7）
   
   现在 4 的结构临时变为：
   
       4
     /   \
    7     2
   / \   / \
   
   
   6 9 1 3 ← 注意：子树本身还没翻到底层，只是第一层指针换了
   
   - 递归处理**新左子树**：`invertTree(7)`
   - 再递归处理**新右子树**：`invertTree(2)`
   
   
   
   进入 invertTree(7)
   
   交换 7.left 和 7.right（6 ↔ 9）
   
   7 的局部结构变为：
   
     7
    / \
   9   6
   
   
   递归处理 invertTree(9)（新左）
   
   递归处理 invertTree(6)（新右）
   
   进入 invertTree(9)
   
   交换 9.left 和 9.right（二者本来就是 None ↔ None）
   
   递归处理 invertTree(None)（左）→ 直接返回
   
   递归处理 invertTree(None)（右）→ 直接返回
   
   返回节点 9（以 9 为根的子树翻转完成）
   
   回到 invertTree(7)，进入 invertTree(6)
   
   交换 6.left 和 6.right（None ↔ None）
   
   递归左右都是 None，直接返回
   
   返回节点 6（以 6 为根的子树翻转完成）
   
   invertTree(7) 的左右子树都处理完，返回节点 7
   此时整棵以 7 为根的子树已经完全翻转为：
   
     7
    / \
   9   6
   
   
   回到 invertTree(4)，进入 invertTree(2)（还记得第 1 步交换后，4 的右子树是 2）
   
   交换 2.left 和 2.right（1 ↔ 3）
   
   2 的局部结构变为：
   
     2
    / \
   3   1
   
   
   递归 invertTree(3)（新左）
   
   递归 invertTree(1)（新右）
   
   进入 invertTree(3)
   
   交换 3.left 与 3.right（None ↔ None）
   
   递归左右都是 None，返回 3
   
   回到 invertTree(2)，进入 invertTree(1)
   
   交换 1.left 与 1.right（None ↔ None）
   
   递归左右都是 None，返回 1
   
   invertTree(2) 完成，返回 2（子树是 2(3,1)）
   
   invertTree(4) 左右子树都翻好，返回 4。全树翻转完成。
   
   2.3 翻转后的整树
   
   现在整棵树变为：
   
            4
          /   \
         7     2
        / \   / \
       9   6 3   1
   ```

2. 迭代思想

```python
class Solution(object):
	def invertTree(self, root):
		"""
		:type root: TreeNode
		:rtype: TreeNode
		"""
		if not root:
			return None
		# 将二叉树中的节点逐层放入队列中，再迭代处理队列中的元素
		queue = [root]
		while queue:
			# 每次都从队列中拿一个节点，并交换这个节点的左右子树
			tmp = queue.pop(0)
			tmp.left,tmp.right = tmp.right,tmp.left
			# 如果当前节点的左子树不为空，则放入队列等待后续处理
			if tmp.left:
				queue.append(tmp.left)
			# 如果当前节点的右子树不为空，则放入队列等待后续处理	
			if tmp.right:
				queue.append(tmp.right)
		# 返回处理完的根节点
		return root
```

