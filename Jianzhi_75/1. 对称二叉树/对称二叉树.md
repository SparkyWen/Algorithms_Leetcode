# 对称二叉树

## 1. 知识点

1. ### 真值（truthiness）

   1. `False、None、0、0.0、空容器([] {} () '' set() range(0))` 为 **假**。

      其他对象通常为 **真**（除非类自定义了 `__bool__`/`__len__` 返回 0/False）。

2. ### 短路（short-circuit）与**返回值**（不一定是 bool）

   1. `and `

      1. 规则：**返回第一个为假的操作数**；若都为真，返回**最后一个操作数**。

         会短路：一旦左边是假，就不再计算右边。

      2. 举例：

         ```python
         0 and 100        # -> 0
         "" and "abc"     # -> ""
         2 and 3          # -> 3
         [1] and "ok"     # -> "ok"
         ```

      2. ` or`

         1. 规则：**返回第一个为真的操作数**；若都为假，返回**最后一个操作数**。

            会短路：一旦左边为真，就不再计算右边。

      3. 逻辑含义与真值表

         1. `A and B`：两者都真 → 真，否则假。

            `A or B`：至少一个真 → 真，否则假。

      4. # 4) 运算符优先级（重要）

         优先级：`not` **高于** `and`，`and` **高于** `or`。
          因此：`A or B and C` 解析为 `A or (B and C)`。
          建议：**加括号**让意图更清楚，尤其是复杂条件。

      5. # 5)德摩根律（De Morgan)

         - `not (A and B)` ⇔ `(not A) or (not B)`

         - `not (A or B)`  ⇔ `(not A) and (not B)`
            读复杂条件时很有用；也能帮助你把“别扭”的写法改成更顺口的形式。

         - 举例：

           ```python
           if not root or not (root.left or root.right):
               return True
           
           not root：空树直接对称。
           
           not (root.left or root.right)：左右孩子都不存在（单节点树）也对称。
           等价于 root.left is None and root.right is None。
           
           if not (left or right):
               continue
           两个都空：这一对“对称成立”，跳过继续。
           等价：if left is None and right is None: continue
           ```

            6. 解释题意:

               ```python
               if not (left or right):  # 两个都不存在 -> True
               if not (left and right): # 至少有一个不存在 -> False
               ```

## 2. 递归思想算法

```python
# Definition for a binary tree node.
# class TreeNode:
#     def __init__(self, val=0, left=None, right=None):
#         self.val = val
#         self.left = left
#         self.right = right
class Solution:
    def isSymmetric(self, root: Optional[TreeNode]) -> bool:
        # 空树视为对称，直接返回 True。
        # if not root 等价于 if root is None
        if not root:
            return True
        def dfs(left, right):
            if not (left or right):
                return True
            if not (left and right):
                return False
            if left.val != right.val:
                return False
            return dfs(left.left, right.right) and dfs(left.right, right.left)
        # 因为root不是空，所以执行这一步
        return dfs(root.left, root.right)
```

主要是递归的思想，但是由于链表表现更好，所以提供算法2

## 3. 链表思想算法

```python
# Definition for a binary tree node.
# class TreeNode:
#     def __init__(self, val=0, left=None, right=None):
#         self.val = val
#         self.left = left
#         self.right = right
class Solution:
    def isSymmetric(self, root: Optional[TreeNode]) -> bool:
        if not root or not(root.left or root.right):
            return True
        queue = [root.left, root.right]
        while queue:
            # 从队列中取出两个节点，再比较这两个节点
            left = queue.pop(0)
            right = queue.pop(0)
            # 如果两个节点都为空就继续循环，两者有一个为空就返回false
            if not (left or right):
                continue 
            if not (left and right):
                return False
            if left.val != right.val:
                return False
            # 将左节点的左孩子， 右节点的右孩子放入队列
            queue.append(left.left)
            queue.append(right.right)
            # 将左节点的右孩子，右节点的左孩子放入队列
            queue.append(left.right)
            queue.append(right.left)
        return True
```

