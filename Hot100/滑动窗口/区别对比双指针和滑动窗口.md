# 区别对比双指针和滑动窗口

1. **滑动窗口 是 双指针 的一种“特殊形态”。**
2. 但“普通双指针”不一定在维护一个“窗口”，思路和题型会比滑动窗口更宽。

下面我用对比的方式讲，你看完会有一个很清晰的脑图：

> 「什么时候叫双指针，什么时候是滑动窗口，写法和思路差在哪」。

## 1. 知识点

------

### 一、什么叫“双指针”？

**双指针 = 用两个索引 / 指针，去优化原本的两重循环。**

它的形式非常自由，常见几种：

#### 1）相向双指针：从两端往中间走

经典例子：**有序数组 two-sum**

```
def twoSum(nums, target):
    i, j = 0, len(nums)-1
    while i < j:
        s = nums[i] + nums[j]
        if s == target:
            return i, j
        elif s < target:
            i += 1      # 想让和变大
        else:
            j -= 1      # 想让和变小
```

特点：

- 两个指针 `i, j` 在同一个数组上；
- 每次只关心 **一对元素 `(nums[i], nums[j])`**；
- 中间那一堆元素并不当作“候选集合”来维护；
- 利用“有序”这个性质，做到 O(n)。

> 这里虽然也有 `[i, j]` 范围，但我们根本**没把它当成一整个“窗口”来维护**，只是借助两端元素的大小关系来收缩范围。

------

#### 2）同向双指针：快慢指针

比如：**删除有序数组中的重复项**

```
def removeDuplicates(nums):
    if not nums:
        return 0
    slow = 0
    for fast in range(1, len(nums)):
        if nums[fast] != nums[slow]:
            slow += 1
            nums[slow] = nums[fast]
    return slow + 1
```

特点：

- `fast` 扫描整个数组；
- `slow` 标记“有效区域的最后一个位置”；
- 并没有维护一个完整的 `[slow, fast]` 窗口，只是用两个位置做“读写分离”。

再比如链表判环：`slow` 每次走一步，`fast` 每次走两步。
 这个其实也是双指针，但根本毫无“滑动窗口”的影子。

------

**小结：**

> 双指针是一种**很宽泛的套路名词**：
>  只要你有两个指针在动，用来优化两重循环，都可以叫双指针。
>  它可以在数组、字符串、链表上用，形态非常多。

------

### 二、什么叫“滑动窗口”？

**滑动窗口 = 一种非常具体的双指针用法：用 `[left, right]` 表示一个“连续子数组 / 子串”，并维护这个区间里的信息。**

特点非常鲜明：

1. **窗口 = 必须是“连续的一段”**：`s[left:right+1]`
2. **窗口里的所有元素都被当作“候选集合”统一处理**
3. 典型形式：
   - 右指针不断往右扩（窗口变大）；
   - 必要时左指针右移（窗口缩小）；
   - 在每一轮上，窗口都满足/逼近某种条件。

比如你刚学的两类：

#### 1）不定长滑窗模板（最长/最短类）

> 例如“最长无重复子串”

```
left = 0
window = ...
ans = 0
for right, ch in enumerate(s):
    # 右端点进窗口
    add(ch, window)

    # 当窗口不合法，缩左边
    while not valid(window):
        remove(s[left], window)
        left += 1

    # 现在窗口合法，更新答案（比如最长长度）
    ans = max(ans, right-left+1)
```

这里的 `[left, right]` **就是真正的“窗口”**，你维护的是：

> 当前窗口 s[left:right+1] 里“所有字符”的某种统计信息（比如频数、和、不同字符数量等）。

#### 2）定长滑窗模板（枚举固定长度子串）

> 例如“找所有长度为 len(p) 的异位词子串”

```
k = len(p)
window = ...
for right, ch in enumerate(s):
    add(ch, window)
    if right >= k:
        remove(s[right-k], window)  # 保证长度 == k
    if right >= k-1 and good(window):
        记录答案
```

**核心：**

- `[right-k+1, right]` 这段，始终被当作一个“整体窗口”来维护；
- 你对这个窗口每次都要统计信息（sum、Counter 等）。

------

### 三、关系：滑动窗口 ⊂ 双指针

你可以这样理解：

> - **双指针 = 大家族**，包括：
>   - 相向双指针（two-sum、盛水容器、回文判断…）
>   - 同向快慢指针（删除重复、链表判环…）
>   - 两数组双指针合并（归并排序 merge）
>   - ……等等
> - **滑动窗口 = 其中一个子分支**：
>    专门解决“**连续子数组 / 子串 + 某种性质**”的问题。

所以你说：

> “好像滑动窗口问题本质就是双指针问题？”

是对的，可以更精确地说：

> **所有滑动窗口都是双指针；但不是所有双指针都是滑动窗口。**

------

### 四、它们“做法上的区别”到底在哪？

可以从三个角度来区分：**问题类型、指针含义、典型代码形状**。

#### 1）问题类型上怎么判断？

**通常是滑动窗口的题：**

- 题目里出现：
  - “子串 / 子数组”
  - “连续的一段”
- 问法是：
  - 最长 / 最短 满足某条件的子串
  - 所有长度为 k 的子串满足某性质的个数 / 位置
  - 子串中字符出现次数 / 种类 / 和 / 平均值之类的统计
- 典型例子：
  - 最长无重复子串
  - 最小覆盖子串
  - 至多 K 个不同字符的最长子串
  - 找所有异位词起点
  - 固定长度 k 的最大平均值

**通常是“一般双指针”，但不是滑动窗口的题：**

- 题目里强调：
  - 数组已排序，找两数之和 = target
  - 在有序数组上原地删除重复
  - 合并两个有序数组/链表
  - 链表判环、找环入口
- 典型例子：
  - Two Sum II（有序数组）
  - Remove Duplicates from Sorted Array
  - Merge Two Sorted Lists
  - 环形链表（快慢指针）

**一句话区分：**

> - 如果题目重点是：**“所有的连续子区间 / 子串 中，找满足条件的那些”** → 八成滑动窗口。
> - 如果重点是：**“通过两个位置的关系来剪枝 / 优化”**，而不特别强调整个区间 → 更大概率是普通双指针。

------

#### 2）两个指针的“含义”不一样

**滑动窗口：**

- `left` / `right` 共同定义一个窗口 `[left, right]`；
- 这个窗口对应的子数组/子串是整个算法关注的对象；
- 随时维护窗口里的整体信息：
  - 频数（`Counter` / 数组）
  - 总和、平均值
  - 不同元素数量……

**一般双指针：**

- 两个指针未必形成一个“窗口”：
  - `i`、`j` 只是两个下标，表示两个元素、两条链表的当前位置等；
  - 比如 two-sum，只关心 `nums[i] + nums[j]` 这对组合；
  - 快慢指针，根本不管中间那些节点组成什么“区间”。

------

#### 3）典型代码形状不同

**滑动窗口的典型样子：**

> 不定长：

```
left = 0
for right in range(n):
    # 右指针扩展窗口
    add(nums[right])

    # 不合法就收缩窗口
    while not valid():
        remove(nums[left])
        left += 1

    # 此时窗口合法，可以用它更新答案
    更新答案
```

> 定长：

```
for right in range(n):
    add(nums[right])
    if right >= k:
        remove(nums[right-k])
    if right >= k-1 and valid():
        记录答案
```

**普通双指针常见形态：**

> 相向：

```
i, j = 0, n-1
while i < j:
    if 条件满足:
        ...
    elif 需要变大:
        i += 1
    else:
        j -= 1
```

> 同向快慢：

```
slow = 0
for fast in range(n):
    if 条件满足:
        slow += 1
        赋值 / 覆盖
```

> 链表快慢：

```
slow, fast = head, head
while fast and fast.next:
    slow = slow.next
    fast = fast.next.next
```

你看，**滑动窗口那两段模板，都明显是在维护 `[left, right]` 这一整段区间的状态**；
 而一般双指针只是让两个位置满足某种关系，并不一定有“窗口”的概念。



## 2. 代码

### 一、不定长滑动窗口：典型代码长这样

以「最长无重复子串」为例：

```
def lengthOfLongestSubstring(s: str) -> int:
    window = set()    # 维护窗口内的字符
    left = 0
    ans = 0

    for right, ch in enumerate(s):
        # 1. 右指针右移：把新字符加入窗口
        while ch in window:        # ❗窗口不合法（有重复）
            window.remove(s[left]) # 左指针右移前，先把左边字符移出窗口
            left += 1

        window.add(ch)             # 加入新字符后，窗口合法
        ans = max(ans, right - left + 1)  # 用当前窗口更新答案

    return ans
```

**代码特征（滑动窗口）：**

1. **始终维护一个“区间结构”**，比如 `window`（`set`/`Counter`/sum/...），
    每一次 `left` 或 `right` 变化，都会同步更新这个结构。

2. 外层通常是：

   ```
   for right in range(n):  # 或 while right < n
       # 先扩张右边
       add(s[right])
   
       # 发现“窗口不合法”就 while 缩左边
       while not valid(window):
           remove(s[left])
           left += 1
   
       # 此时窗口合法，用它更新答案
       update answer
   ```

   **模式：`right` 一格一格走，`left` 在 while 里追。**

3. `right - left + 1` 是**窗口长度**，经常用于更新答案或判断条件。

4. 每一步都关心的是整个 `[left, right]` 这一段子串/子数组。

------

### 二、定长滑动窗口：典型代码长这样

以「找到所有异位词」为例（你刚学的定长写法）：

```
from collections import Counter

def findAnagrams(s: str, p: str):
    n, m = len(s), len(p)
    if n < m:
        return []

    cnt_p = Counter(p)
    cnt_s = Counter()
    ans = []

    for right, ch in enumerate(s):
        cnt_s[ch] += 1        # 右端点进入窗口

        if right >= m:
            # 窗口长度 > m 时，移除 left = right-m 位置的字符，保持长度 = m
            out = s[right - m]
            cnt_s[out] -= 1
            if cnt_s[out] == 0:
                del cnt_s[out]

        if right >= m - 1:    # 窗口长度正好为 m
            if cnt_s == cnt_p:
                ans.append(right - m + 1)

    return ans
```

**代码特征（定长滑窗）：**

1. 也是维护一个“窗口结构”`cnt_s`，但窗口长度**始终固定为 m**。

2. 模板形状一般是：

   ```
   for right in range(n):
       add(s[right])              # 加右
   
       if right >= k:
           remove(s[right-k])     # 删左，保持长度 k
   
       if right >= k-1 and valid(window):
           记录答案
   ```

3. 注意没有 `while` 缩左边，因为长度是**定长**，不需要 while 调整，只是每次对应删一个。

------

### 三、普通双指针（非滑动窗口）：代码长这样

#### 例 1：有序数组 two-sum（相向双指针）

```
def twoSum(nums, target):
    i, j = 0, len(nums) - 1
    while i < j:
        s = nums[i] + nums[j]
        if s == target:
            return [i, j]
        elif s < target:
            i += 1      # 为了让和变大
        else:
            j -= 1      # 为了让和变小
```

**注意：**

- 这里有两个指针 `i`、`j`，但我们根本没维护一个“窗口结构”；
- 也没有“窗口合法/不合法”的概念，只是在用 `nums[i] + nums[j]` 与 `target` 比较；
- 每一步只看这一对 `(nums[i], nums[j])`，中间 `[i, j]` 那段不当成整体去维护。

#### 例 2：删除有序数组中的重复项（快慢指针）

```
def removeDuplicates(nums):
    if not nums:
        return 0
    slow = 0
    for fast in range(1, len(nums)):
        if nums[fast] != nums[slow]:
            slow += 1
            nums[slow] = nums[fast]
    return slow + 1
```

**注意：**

- `fast` 用来读，`slow` 用来写；
- 没有任何“窗口统计信息”的结构，也没有“[slow, fast] 这个区间”作为候选子数组；
- 只是「两个位置」配合做事情。

------

### 四、直接对比：代码层面的关键区别

#### ✅ 共同点

- 都有两个指针（下标）：`left/right` 或 `i/j` 或 `slow/fast`；
- 都是为了避免 O(n²) 的双重循环，提高效率。

#### ❌ 关键区别 1：是不是在维护“窗口状态结构”

- **滑动窗口：一定有“窗口状态”结构 + 更新逻辑**

  ```
  window = Counter() / set() / sum / ...
  add(s[right])      # 右指针动时必须更新
  remove(s[left])    # 左指针动时必须更新
  ```

  每次移动指针都会配合更新 `window`，表示当前 `[left, right]` 的整体信息。

- **普通双指针：很多时候没有任何“窗口状态”结构**

  - two-sum：每次只算 `nums[i] + nums[j]`
  - 快慢指针：只用两个位置比较、赋值，不统计区间

------

#### ❌ 关键区别 2：是否存在“窗口合法性 + while 收缩”逻辑

- **滑动窗口（不定长）必有这样的结构：**

  ```
  for right in range(n):
      add(s[right])
      while not valid(window):  # 窗口非法 → 收缩
          remove(s[left])
          left += 1
      # 这里窗口合法
      update answer
  ```

  这里的 `valid(window)` 就是窗口的“合法条件”，比如：

  - 不重复：所有字符频数 ≤ 1
  - 总和 ≤ k
  - 某些字符个数不超过上限……

- **普通双指针**一般没有 “valid(window)” 这个概念，
   更多是“根据当前两指针指向的值，决定怎么移动哪个指针”：

  ```
  while i < j:
      if nums[i] + nums[j] == target:
          ...
      elif nums[i] + nums[j] < target:
          i += 1
      else:
          j -= 1
  ```

  完全没有“窗口统计结构 + while 缩小”的逻辑。

------

#### ❌ 关键区别 3：是否把 `[left, right]` 当作「候选答案」

- **滑动窗口：**
   `[left, right]` 这一段**就是候选子串/子数组本身**：

  ```
  # 无重复最长子串
  ans = max(ans, right - left + 1)
  
  # 找异位词
  if right - left + 1 == len(p) and valid(window):
      ans.append(left)
  ```

- **普通双指针：**
   `[i, j]` 不一定是候选答案：

  - two-sum：答案是一对 `(i, j)`，不是区间 `[i, j]`
  - 删除重复：答案是 nums[0:slow+1]，但过程不是在维护“窗口合法性”，而是在控制写入位置