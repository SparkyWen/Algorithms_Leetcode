# 无重复字符的最长子串

## 1. 知识点

### 1、 什么是滑动窗口

其实就是一个队列,比如例题中的 abcabcbb，进入这个队列（窗口）为 abc 满足题目要求，当再进入 a，队列变成了 abca，这时候不满足要求。所以，我们要移动这个队列！

如何移动？

我们只要把队列的左边的元素移出就行了，直到满足题目要求！

一直维持这样的队列，找出队列出现最长的长度时候，求出解！

时间复杂度：O(n)

### 2、 Counter()实例的介绍

#### 1. Counter 是什么？

```
from collections import Counter
```

- `Counter` 是 `collections` 模块里提供的一个 **类**。
- 它是 `dict` 的子类，长得很像字典：`{元素: 出现次数}`。
- 里面的「键」是**元素**（必须是可哈希的，比如 int、str、tuple），
- 「值」是**出现的次数**（int）。

你看到的结果类似：

```
Counter({'a': 3, 'b': 2, 'c': 1})
```

可以理解成：底层就是

```
{'a': 3, 'b': 2, 'c': 1}
```

只是多了一些专门为“计数”设计的功能。

------

#### 2. 最常见的三种初始化方式

##### 2.1 直接用可迭代对象（列表 / 字符串等）

```
from collections import Counter

c = Counter(['a', 'b', 'a', 'c', 'b', 'a'])
print(c)         # Counter({'a': 3, 'b': 2, 'c': 1})
```

等价于手写：

```
c = {}
for x in ['a', 'b', 'a', 'c', 'b', 'a']:
    c[x] = c.get(x, 0) + 1
```

**字符串也可以：**

```
s = "abacaba"
c = Counter(s)
print(c)         # Counter({'a': 4, 'b': 2, 'c': 1})
```

> 典型应用：统计字符频率 / 统计数组中每个数字出现次数。

------

##### 2.2 用字典初始化（你自己已经数好）

```
c = Counter({'apple': 3, 'banana': 2})
print(c)  # Counter({'apple': 3, 'banana': 2})
```

------

##### 2.3 用关键字参数初始化

```
c = Counter(a=3, b=2, c=1)
print(c)  # Counter({'a': 3, 'b': 2, 'c': 1})
```

只是写法糖，和上面是一样的效果。

------

#### 3. 和普通 dict 有什么关系？

底层就是哈希表，所以你可以像 dict 一样用：

```
c = Counter("abacaba")

print(c['a'])     # 4
print(c['b'])     # 2
print(c['x'])     # 0  <-- 非常重要
```

**关键区别：**

- `dict` 访问一个不存在的 key 会 `KeyError`
- `Counter` 访问不存在的 key 会返回 **0**

```
d = {}
# d['x'] -> KeyError

c = Counter()
print(c['x'])  # 0
```

这就是它适合做「计数」的原因——不需要自己写 `get(x, 0)` 了。

你可以像操作 dict 一样：

```
c['a'] += 1
c['b'] = 10
del c['a']
'a' in c       # False
```

------

#### 4. Counter 的常用方法（算法题高频）

##### 4.1 `most_common`：找出现次数最多的元素

```
c = Counter("abacaba")

print(c.most_common())    
# [('a', 4), ('b', 2), ('c', 1)]

print(c.most_common(1))  
# [('a', 4)]，Top1

print(c.most_common(2))  
# [('a', 4), ('b', 2)]，Top2
```

> LeetCode 里**前 K 个高频元素**，就很常用这个。

------

##### 4.2 `elements`：按次数把元素“展开”

```
c = Counter(a=2, b=3)
print(list(c.elements()))
# ['a', 'a', 'b', 'b', 'b']  顺序不保证
```

------

##### 4.3 `update`：增加计数（累加）

```
c = Counter("abac")
c.update("aba")  
print(c)  
# Counter({'a': 4, 'b': 2, 'c': 1})
```

等价于再把 `"aba"` 的每个字符统计一次并加上去。

------

##### 4.4 `subtract`：减去计数

```
c = Counter("abac")
c.subtract("aa")  
print(c)
# Counter({'b': 1, 'c': 1, 'a': 0})
```

**注意：**`Counter` 允许出现 **负数**，比如：

```
c = Counter(a=2)
c.subtract("aaa")      # 减掉3个 a
print(c)               # Counter({'a': -1})
```

------

#### 5. Counter 的「多集合运算」

Counter 也可以做集合运算，只不过是对**计数**做运算：

```
c1 = Counter("aabbc")   # Counter({'a': 2, 'b': 2, 'c': 1})
c2 = Counter("abccc")   # Counter({'c': 3, 'a': 1, 'b': 1})
```

##### 5.1 加法：计数相加

```
print(c1 + c2)
# Counter({'a': 3, 'b': 3, 'c': 4})
```

##### 5.2 减法：相减（只保留 > 0 的）

```
print(c1 - c2)
# Counter({'a': 1, 'b': 1})
```

##### 5.3 交集：每个元素取 **最小** 计数

```
print(c1 & c2)
# Counter({'a': 1, 'b': 1, 'c': 1})
```

##### 5.4 并集：每个元素取 **最大** 计数

```
print(c1 | c2)
# Counter({'c': 3, 'a': 2, 'b': 2})
```

可以把 `Counter` 看成一个**多重集合（multiset）**：同一个元素可以有多个“个数”。

------

#### 6. 和「哈希 map」的关系到底是什么？

你说的「结果是一个哈希 map？」本质上理解是**对的**：

- 在 Python 里，「哈希 map」就是 `dict`；
- `Counter` 是 `dict` 的子类，底层也是用哈希表存储；
- 差别在于：
  - `dict` 是「key -> value（随便什么东西）」
  - `Counter` 约定「key -> 计数（int）」并给你很多与“计数”相关的工具。

如果用更贴近底层的描述：

> `Counter` = 在 `dict`（哈希表）上，包了一层「统计频率」的封装 + 一堆专门为统计设计的方法。

### 3. Counter()实例的计算

#### `cnt[c] += 1` 具体在干嘛？给你单独举例

先看一段小代码：

```
from collections import Counter

cnt = Counter()
s = "abac"

for i, c in enumerate(s):
    cnt[c] += 1
    print(f"i={i}, c={c}, cnt={cnt}")
```

运行过程可以想象成：

1. 初始：`cnt = Counter()`，相当于空字典 `{}`。
2. i = 0, c = 'a'
   - 原来 `cnt['a']` 默认是 0（Counter 的特点）
   - 执行 `cnt['a'] += 1` → 0 + 1 = 1
   - 此时 `cnt = {'a': 1}`
3. i = 1, c = 'b'
   - 原来 `cnt['b']` 是 0
   - `cnt['b'] += 1` → 1
   - `cnt = {'a': 1, 'b': 1}`
4. i = 2, c = 'a'
   - 原来 `cnt['a']` 是 1
   - `cnt['a'] += 1` → 2
   - `cnt = {'a': 2, 'b': 1}`
5. i = 3, c = 'c'
   - 原来 `cnt['c']` 是 0
   - `cnt['c'] += 1` → 1
   - `cnt = {'a': 2, 'b': 1, 'c': 1}`

## 2. 代码

### 1. 题解：用 `set` 的版本

核心变量：

```python
left = 0
lookup = set()   # 当前窗口里的字符集合
cur_len = 0      # 当前窗口长度
max_len = 0      # 最大长度
```

循环：

```python
for i in range(n):      # i 就是右指针 right
    cur_len += 1        # 先把右边这个字符算进长度
    while s[i] in lookup:      # 如果重复了
        lookup.remove(s[left]) # 把最左边的字符从集合里删掉
        left += 1              # 左指针右移
        cur_len -= 1           # 窗口长度减一
    if cur_len > max_len:
        max_len = cur_len
    lookup.add(s[i])           # 把当前字符放进集合
```

**不变量：**
 循环结束后，总能保证当前窗口 `[left, i]` 里 *没有重复字符*，因为一旦 `s[i]` 在集合里，while 就一直删左边直到 `s[i]` 不在集合里。

### 2. 你的版本：用 `Counter` 的版本

（我把缺的导入补全一下）

```
from collections import Counter

class Solution:
    def lengthOfLongestSubstring(self, s: str) -> int:
        ans = 0
        cnt = Counter()      # 记录窗口里每个字符出现的次数
        left = 0             # 左指针

        for right, c in enumerate(s):  # right 是右指针，c = s[right]
            cnt[c] += 1                # 新字符进窗口，次数 +1

            while cnt[c] > 1:          # 如果当前字符 c 出现次数 > 1，说明重复了
                cnt[s[left]] -= 1      # 把最左边字符移出窗口，次数 -1
                left += 1              # 左指针右移

            ans = max(ans, right - left + 1)

        return ans
```

这里的**不变量**是：

> 任何时刻，`cnt[x]` 都表示：当前窗口 `s[left : right+1]` 中字符 `x` 出现的次数。
>  并且 while 结束后，`cnt[c] == 1`，窗口里不再有重复的 `c`。

可以看到，两者的思想一模一样：

- ==遇到新字符（右指针前进）==；
- 如果重复，就不断移动左指针，把左边的字符从窗口里“删掉”；
- 删除方式：
  - `set`：`lookup.remove(s[left])`
  - `Counter`：`cnt[s[left]] -= 1`
- 一旦窗口合法（无重复），就更新答案。

区别只是：
**==`set` 只知道“有没有”，`Counter` 还知道“有几个”==**

**==这里我存在一个理解偏差，就是我认为如果有重复的，就一定是和最左边的重复，可是不一定是这样子。==如下：**

#### 1. 为什么 `cnt[s[right]] -= 1` 会错？看一个真实反例

用经典反例：`"pwwkew"`
 正确答案是 3（最长无重复子串 `"wke"`）。

##### ✅ 正确写法：`cnt[s[left]] -= 1`

代码结构：

```
cnt[c] += 1
while cnt[c] > 1:
    cnt[s[left]] -= 1
    left += 1
```

当走到 `right = 2`（第二个 'w'）时，状态是：

- 字符串：`p w w k e w`
- 索引：   `0 1 2 3 4 5`

此时：

```
right = 2, c = 'w'
窗口 = s[0:3] = "pww"
cnt = {'p':1, 'w':2}
```

`cnt[c] = cnt['w'] = 2 > 1`，进入 `while`。

**第一次 while：**

```
cnt[s[left]] -= 1   # s[left] = s[0] = 'p'
cnt['p'] -= 1 -> 0
left += 1           # left: 0 -> 1
窗口 = s[1:3] = "ww"
cnt = {'p':0, 'w':2}
```

`cnt[c] = cnt['w']` 还是 2 > 1，继续 while。

**第二次 while：**

```
cnt[s[left]] -= 1   # s[left] = s[1] = 'w'
cnt['w'] -= 1 -> 1
left += 1           # left: 1 -> 2
窗口 = s[2:3] = "w"
cnt = {'p':0, 'w':1}
```

现在 `cnt['w'] == 1`，退出 while。
 **注意：此时窗口真正只剩下一个 'w'，Counter 里的统计也正好是 1，一一对应。**

------

##### ❌ 错误写法：`cnt[s[right]] -= 1`

你想写成：

```
cnt[c] += 1
while cnt[c] > 1:
    cnt[s[right]] -= 1     # 也就是 cnt[c] -= 1
    left += 1
```

我们再看同样的位置 `right = 2`：

初始：

```
right = 2, c = 'w'
窗口 = "pww"
cnt = {'p':1, 'w':2}
```

`cnt[c] = 2 > 1`，进入 while：

```
cnt[s[right]] -= 1   # s[right] = s[2] = 'w'
cnt['w'] -= 1 -> 1
left += 1            # left: 0 -> 1
窗口 = s[1:3] = "ww"
cnt = {'p':1, 'w':1}
```

现在看一下：

- **窗口里实际有两个 'w'（"ww"），但 `cnt['w']` 变成了 1**；
- `cnt[c] = cnt['w'] = 1`，所以 while 结束。

也就是说：

> **窗口里明明还有重复字符，但你的 `Counter` 已经“自欺欺人”地说自己没有重复了。**

这就是 bug 的根源。

后面继续往右扩展时，你的程序会把 `"wwke"` 这种长度 4 的窗口也当成“无重复”的，最后返回 4，而正确答案应该是 3。