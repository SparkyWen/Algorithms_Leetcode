# 字母异位词分组

## 1. 知识点

> 1. 本质上， 理解一下就是要求字母数量相同，而且要求字母相同

> 2. 做法：
>    1. 排序
>    2. 计数数组

> 3. 补充知识点:
>
> ```python
> 排序:
> sorted()
> 
> 1. 升序排列（从小到大）
> 
> sorted_nums = sorted(nums)          # 返回新的升序列表
> # 或者就地排序：
> nums.sort()                         # 直接把 nums 变成升序
> 
> 
> 2. 降序排列（从大到小）
> 
> sorted_nums_desc = sorted(nums, reverse=True)  # 返回新的降序列表
> # 或者就地排序：
> nums.sort(reverse=True)                        # 直接把 nums 变成降序
> 
> 
> sorted() 不会修改原来的序列，而是返回一个新列表；
> list.sort() 是在原列表上修改。
> 
> 如果你要按某个规则排序，比如按字符串长度升序：
> 
> words = ["python", "ai", "chatgpt"]
> sorted_words = sorted(words, key=len)          # 按长度升序
> sorted_words_desc = sorted(words, key=len, reverse=True)  # 按长度降序
> ```

4. 字典知识补充：

```python
1. d = defaultdict(list) 是什么？
普通 dict 的问题

如果我们用普通字典写，会是这样：

d = {}
for s in strs:
    key = ...
    if key not in d:
        d[key] = []      # 先手动建一个空列表
    d[key].append(s)


也就是说：每次用一个新 key 时，都要先判断 “有没有这个 key”，如果没有，要先创建一个空列表。

```

defaultdict(list) 在干嘛？

defaultdict 是 collections 里的一个特殊字典类。
defaultdict(list) 的意思是：

==**当访问一个不存在的 key 时，自动帮你创建一个“默认值”为 list()（也就是空列表 []）的条目。**==

**小例子：**

```python
from collections import defaultdict

d = defaultdict(list)

print(d)               # defaultdict(<class 'list'>, {})

d['a'].append(1)
d['a'].append(2)
d['b'].append(3)

print(d)
# defaultdict(<class 'list'>, {'a': [1, 2], 'b': [3]})

.append(1)、2、3 究竟是什么？

.append(...) 是 列表对象的“方法调用”，具体来说：

语法：对象.方法名(参数)

这里的“对象”是 d['a'] 或 d['b']（它们都是 list）

“方法名”是 append

参数是你要加进去的元素 1、2、3

所以：

d['a'].append(1)：往 d['a'] 这个列表结尾追加一个元素 1

d['a'].append(2)：再追加一个 2

d['b'].append(3)：往 d['b'] 这个列表结尾追加一个元素 3

它 不是赋值语句（赋值语句通常是 =），而是对已有对象进行修改。
```

### 为什么返回d.values()：

因为这时候 `d` 的“键-值”结构是：

```
{
  "aet": ["eat", "tea", "ate"],
  "ant": ["tan", "nat"],
  "abt": ["bat"]
}
```

- **键 key**：`"aet"`, `"ant"`, `"abt"` —— 是“排序后的单词”
- **值 value**：每个 key 对应的一堆原始单词 —— 就是一组字母异位词

题目要求的输出是：**“按组返回这些字符串”**，也就是：

```
[["eat","tea","ate"], ["tan","nat"], ["bat"]]
```

只要这些“组”，并不需要中间那个 key（`"aet"` 这些）。

而 `d.values()` 恰好就是“所有 value 的视图”：

```
d.values()
# -> dict_values([["eat", "tea", "ate"], ["tan", "nat"], ["bat"]])
```

再套一个 `list(...)`，就变成真正的列表：

```
return list(d.values())
# -> [["eat","tea","ate"], ["tan","nat"], ["bat"]]
```

这就是为什么返回 `d.values()` —— 我们只关心**每组字母异位词的列表**，不关心每组对应的那个 key。

## 2. 代码

```python
class Solution:
    def groupAnagrams(self, strs: List[str]) -> List[List[str]]:
        d = defaultdict(list)  # 如果 key 不在字典中，则自动插入一个空列表
        for s in strs:
            sorted_s = ''.join(sorted(s))  # 把 s 排序，作为哈希表的 key
            d[sorted_s].append(s)  # 排序后相同的字符串分到同一组
        return list(d.values())  # 哈希表的 value 保存分组后的结果
```