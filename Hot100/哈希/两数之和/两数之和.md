# 两数之和

## 1. 知识点

> 1. **思路**
>    标签：哈希映射
>    这道题本身如果通过暴力遍历的话也是很容易解决的，时间复杂度在 O(n2)
>    由于哈希查找的时间复杂度为 O(1)，所以可以利用哈希容器 map 降低时间复杂度
>    遍历数组 nums，i 为当前下标，每个值都判断map中是否存在 target-nums[i] 的 key 值
>    如果存在则找到了两个值，如果不存在则将当前的 (nums[i],i) 存入 map 中，继续遍历直到找到为止
>    如果最终都没有结果则抛出异常

> 2. 解释复杂度
>
> 问：是什么原因导致了这两种算法的快慢？
>
> 答：我用「获取了多少信息」来解释。
>
> 暴力做法每次拿两个数出来相加，和 target 比较，那么花费 O(1) 的时间，只获取了 O(1) 的信息。
>
> 而哈希表做法，每次查询都能知道 O(n) 个数中是否有 target−nums[j]，那么花费 O(1) 的时间，就获取了 O(n) 的信息。
>
> 这就是为什么我们可以把暴力的 O(n^2^) 优化成 O(n)。

## 2. 代码

```python
class Solution:
    def twoSum(self, nums: List[int], target: int) -> List[int]:
        idx = {}  # 创建一个空哈希表（字典）
        for j, x in enumerate(nums):  # x=nums[j]
            if target - x in idx:  # 在左边找 nums[i]，满足 nums[i]+x=target
                return [idx[target - x], j]  # 返回两个数的下标
            idx[x] = j  # 保存 nums[j] 和 j
```

