# 三数之和

## 1. 知识点

> 1. 难点：如何处理重复值以及如何处理双指针
> 2. 思路：这里就没有想起sort来排序处理
>
> 思路
> 标签：数组遍历
> 首先对数组进行排序，**排序后固定一个数 nums[i]**，再使用左右指针指向 nums[i]后面的两端，数字分别为 nums[L] 和 nums[R]，计算三个数的和 sum 判断是否满足为 0，满足则添加进结果集
>
> 1. 如果 nums[i]大于 0，则三数之和必然无法等于 0，结束循环
> 2. 如果 nums[i] == nums[i−1]，则说明该数字重复，会导致结果重复，所以应该跳过
> 3. 当 sum == 0 时，nums[L] == nums[L+1] 则会导致结果重复，应该跳过，L++
> 4. 当 sum == 0 时，nums[R] == nums[R−1] 则会导致结果重复，应该跳过，R−−
> 5. 时间复杂度：O(n^2^ )，n 为数组长度
>
> 3. 执行过程：
>
> <img src="https://pic.leetcode-cn.com/05bd0c05ada0193c35575e91a2dcb47496b2f970bcee0b60c5610bb3b0e1d5ee-0.png" style="zoom:50%;" />
>
> <img src="https://pic.leetcode-cn.com/00a09d9a4652c19ca3d1022b99a2395ae2f874bc4e41d19a4c61434566b156ec-2.png" style="zoom:50%;" />
>
> 

## 2. 代码

先将 nums 排序，时间复杂度为 O(NlogN)。

固定 3 个指针中最左（最小）元素的指针 k，双指针 i，j 分设在数组索引 (k,len(nums)) 两端。

双指针 i , j 交替向中间移动，记录对于每个固定指针 k 的所有满足 nums[k] + nums[i] + nums[j] == 0 的 i,j 组合：

当 nums[k] > 0 时直接break跳出：因为 nums[j] >= nums[i] >= nums[k] > 0，即 3 个元素都大于 0 ，在此固定指针 k 之后不可能再找到结果了。
当 k > 0且nums[k] == nums[k - 1]时即跳过此元素nums[k]：因为已经将 nums[k - 1] 的所有组合加入到结果中，本次双指针搜索只会得到重复组合。
i，j 分设在数组索引 (k,len(nums)) 两端，当i < j时循环计算s = nums[k] + nums[i] + nums[j]，并按照以下规则执行双指针移动：
当s < 0时，i += 1并跳过所有重复的nums[i]；
当s > 0时，j -= 1并跳过所有重复的nums[j]；
当s == 0时，记录组合[k, i, j]至res，执行i += 1和j -= 1并跳过所有重复的nums[i]和nums[j]，防止记录到重复组合。

```python
class Solution:
    def threeSum(self, nums: List[int]) -> List[List[int]]:
        nums.sort()
        res, k = [], 0
        # 注意这里是-2，因为还有另外两个指针，思考上不用考虑
        for k in range(len(nums)-2):
            # 1. because of j > i > k.
            if nums[k] > 0:break
            # 2. skip the same `nums[k]`.但是这里我没有想明白为什么要k>0？
            if k > 0 and nums[k] == nums[k-1]:continue
            i, j = k+1, len(nums)-1
            while i < j :
                s = nums[k] + nums[i] + nums[j]
                if s < 0:
                    i += 1
                    while i < j and nums[i] == nums[i-1]: i += 1
                elif s > 0:
                    j -= 1
                    while i < j and nums[j] == nums[j+1]: j-=1
                else:
                    res.append(nums[k], nums[i], nums[j])
                    i += 1
                    j -= 1
                    while i < j and nums[i] == nums[i - 1]: i += 1
                    while i < j and nums[j] == nums[j + 1]: j -= 1
        return res
```

## 一、三数之和的整体思路（先不用看代码）

问题：在数组 `nums` 里，找所有 **a + b + c = 0** 的三元组，不能重复。

### 1. 朴素想法：三重循环 O(n³)

最直接：
 `for k in ...: for i in ...: for j in ...:`  枚举所有三元组，时间复杂度 O(n³)，太慢。

### 2. 优化思路：把「三数之和」拆成「一数 + 两数之和」

核心想法：

> 先**固定一个数 nums[k]**，然后在它右边的子数组里，找**两个数的和 = -nums[k]**。
>  这样就变成「Two Sum 经典题」+ 双指针。

- 外层循环：枚举第一个数的下标 `k`
- 里层用两个指针 `i, j`（`i` 从左，`j` 从右）在区间 `(k, end]` 内找两数之和 = `-nums[k]`

### 3. 为什么要先排序？

因为两数之和用双指针这个套路要求：**数组是有序的**，这样：

- 如果当前和 **太小**：把左指针右移，和会变大
- 如果当前和 **太大**：把右指针左移，和会变小

## 二、双指针是如何思考的？

以固定 `nums[k]` 后，在右边找 `nums[i] + nums[j] = -nums[k]` 为例：

- 设 `target = -nums[k]`
- 初始：`i = k+1`（紧挨着 k 的下一个）
   `j = len(nums)-1`（最右边）

然后循环：

1. 计算当前和：`s = nums[i] + nums[j]`
2. 如果 `s < target`
    说明和太小了，要更大一点 → 让左边的数大一点 → `i += 1`
3. 如果 `s > target`
    说明和太大了，要小一点 → 让右边的数小一点 → `j -= 1`
4. 如果 `s == target`
    找到一组三元组 `[nums[k], nums[i], nums[j]]`，收集进结果，然后：
   - `i += 1`, `j -= 1` 继续找下一组
   - 并且跳过重复的元素（否则会产生重复解）

**为什么这样一定能遍历完所有可能？**

- 数组是有序的，所以
  - 增大左指针 `i` → 当前和一定不会变小
  - 减小右指针 `j` → 当前和一定不会变大
- 每一步都**排除掉一个区间**而不漏解，这就是双指针的精髓。





## 3. 深入反思为什么我的做法不行

因为我的两数之和的思考和三数之和的思考是完全不同的，我想的是拿hash表去匹配，但是通用的做法是直接排序后移动，我哈希不好处理的点在于重复值，我不知道如何处理，所以这里要用双指针。

## 一、双指针的精髓：有序 + 单调缩小区间

### 1. 以两数之和（Two Sum in sorted array）为例

假设我们要在 **递增数组** `nums` 里找 `nums[i] + nums[j] == target`：

- 初始：`i = 0`（最左）, `j = n-1`（最右）
- 每一步只看这三个东西：

```
s = nums[i] + nums[j]
if s < target: i += 1   # 和太小，左边要大一点
elif s > target: j -= 1 # 和太大，右边要小一点
else: 找到解
```

**关键点：**

- 因为数组是有序的：
  - `i` 向右走 → 左边数一定变大 → `s` 单调不减
  - `j` 向左走 → 右边数一定变小 → `s` 单调不增
- 所以每次移动指针，相当于把一大块区间“整体淘汰”：
  - `s < target` 时，`(i, j)` 这个位置太小
     ⇒ 整个 `i` 左边那一列 `(0..i, j)` 都更小，**都不用看了**，直接 `i+1`
  - `s > target` 时，反过来淘汰右边

这样，**每个元素最多被指针扫一遍**，复杂度 O(n)，而不是暴力的 O(n²)。

> 总结成一句话：
>  **双指针需要两个条件：**
>
> 1. 有序或单调结构
> 2. 移动指针方向能“单调改变”你关心的值（和更大或更小）

三数之和里，一旦固定了 `nums[k]`，右边那段相当于是一个有序数组，我们就在那上面做“两数之和的双指针”。本质完全一样。



### 2）那为什么一定要加 `k > 0` 这个前提？

因为在 Python 里：

- `nums[-1]` 不是“前一个不存在”，而是**最后一个元素**！

如果你写成：

```
if nums[k] == nums[k-1]:
    continue
```

当 `k = 0` 时，它会变成：

```
if nums[0] == nums[-1]:
    continue
```

这会产生两个严重问题：

1. **逻辑错误**：
    第一个元素本来是应该被尝试的（因为它是数组里的“第一次出现”），根本不应该被当成“重复”；
    如果碰巧 `nums[0] == nums[-1]`（比如全是 0：`[0, 0, 0]`），你会直接 `continue` 跳过 `k = 0`，结果整个循环都没真正做事，所有答案都丢了。
2. **语义不符合“跳过重复前缀”的含义**：
    我们真正想比较的是“当前元素和**它前面一个**元素是否相等”，而不是“当前元素和整个数组最后一个元素是否相等”。

所以正确写法一定要加 `k > 0`：

```
if k > 0 and nums[k] == nums[k-1]:
    continue
```

解读：

- `k > 0`：保证“前一个元素”真的存在，并且是我们上一轮用过的起点；
- `nums[k] == nums[k-1]`：只有遇到**相同值的后续出现**时才跳过。

> ✅ 第一次出现的那个数永远不会被跳过
>  ❌ 后面重复出现的相同数才会被跳过

这样既安全又符合去重逻辑。



# 凡是 while / for 循环里，指针会变化，而你的判断条件又依赖这些指针，就必须在循环里用“当前指针值”重新计算判断条件。

