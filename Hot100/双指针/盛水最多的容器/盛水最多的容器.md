# 盛水最多的容器

## 1. 知识点

> 1. 思路：
>
>    在每个状态下，无论长板或短板向中间收窄一格，都会导致水槽 底边宽度 −1 变短：
>
>    若向内 移动短板 ，水槽的短板 min(h[i],h[j]) 可能变大，因此下个水槽的面积 可能增大 。
>    若向内 移动长板 ，水槽的短板 min(h[i],h[j]) 不变或变小，因此下个水槽的面积 一定变小 。
>    因此，初始化双指针分列水槽左右两端，循环每轮将短板向内移动一格，并更新面积最大值，直到两指针相遇时跳出；即可获得最大面积。

> 2. **缩减搜索空间** 的思想
>
>    用一句话概括双指针解法的要点：**指针每一次移动，都意味着排除掉了一个柱子**。
>
>    即解释上方
>
>    ```
>    当前柱子是最两侧的柱子，水的宽度 d 为最大，其他的组合，水的宽度都比这个小。
>    左边柱子较短，决定了水的高度为 3。如果移动左边的柱子，新的水面高度不确定，一定不会超过右边的柱子高度 7。
>    如果移动右边的柱子，新的水面高度一定不会超过左边的柱子高度 3，也就是不会超过现在的水面高度。
>    ```
>
> 3. 这时候全部的搜索空间是：
>
> ![](https://pic.leetcode-cn.com/bbca2fea8e093fef61ecfe822e2668646a24f8bbc7a7a8f10eb0428ead6b1893.jpg)
>
> 由于 i、j 的约束条件的限制，搜索空间是白色的倒三角部分。可以看到，搜索空间的大小是 O(n^2^) 数量级的。如果用暴力解法求解，一次只检查一个单元格，那么时间复杂度一定是 O(n^2^)。要想得到 O(n) 的解法，==**我们就需要能够一次排除多个单元格。**==那么我们来看看，本题的双指针解法是如何削减搜索空间的：
>
> 
>
> 可以看到，无论柱子 i 和 j 哪根更长，我们都可以排除掉一行或者一列的搜索空间。经过 n 步以后，就能排除所有的搜索空间，检查完所有的可能性。搜索空间的减小过程如下面动图所示：
>
> ![](https://pic.leetcode-cn.com/48fa92510ccbc963d7e49da6a2d7302ebf42233345522a42df435df18bc42fa4.gif)

## 2. 代码

```python
class Solution:
    def maxArea(self, height: List[int]) -> int:
        i, j, res = 0, len(height) - 1, 0
        while i < j:
            if height[i] < height[j]:
                res = max(res, height[i] * (j - i))
                i += 1
            else:
                res = max(res, height[j] * (j - i))
                j -= 1
        return res
```

**==所以总结一下双指针，其实就是初始化多个指针，然后每个指针在遍历的过程中有自己的移动或者操作方式==**